# 7주차 테스트 과제(HARD)

## 7주차 과제 체크포인트

### 기본과제

- [x] 총 11개의 파일, 115개의 단위 테스트를 무사히 작성하고 통과시킨다.

#### 질문


> Q. 이벤트는 생성, 수정 되면 fetch를 다시 해 상태를 업데이트 합니다. 이를 위한 제어가 필요할 것 같은데요. 어떻게 작성해야 테스트가 병렬로 돌아도 안정적이게 동작할까요?

> 테스트 간 상태 격리를 위해, 이벤트 저장소는 전역 변수(`eventStore`)로 관리하되, 모든 테스트가 실행될 때마다 `setupMockHandlerCreation()`을 호출하여 새로운 인스턴스로 초기화
>
> 이를 통해, 이벤트의 `생성`, `수정`, `삭제` 후 `fetch`를 통해 상태를 갱신하더라도, 각 테스트는 자신만의 독립된 상태를 기반으로 동작하며 다른 테스트의 상태에 영향을 주지 않음
>
> ```ts
> // handlerUtils.ts
> class EventStore { ... }
>
> let eventStore: EventStore;
>
> export const setupMockHandlerCreation = (initEvents: Event[] = []) => {
>   eventStore = new EventStore(initEvents);
> };
> ```
>
> ```ts
> it("테스트 설명", async () => {
>   const initEvents = [...events] as Event[];
>   setupMockHandlerCreation(initEvents);
>   ...
> });
> ```

> Q. 테스트를 독립적으로 구동시키기 위해 작성했던 설정들을 소개해주세요.

> 1. 테스트마다 명시적 초기화 실행
>
> - 각 테스트에서 `setupMockHandlerCreation()`을 호출하여 테스트별 초기 상태를 설정하고, 상태 간섭을 방지
>
> 2. MSW 핸들러와 eventStore 연동
>
> - 모든 API 요청은 전역 eventStore를 참조하도록 구성하고, fetch 요청은 해당 테스트에서 초기화한 상태만 반영
>
> 3. 실제 사용자 흐름에 가까운 테스트 구조 유지
>
> - 이벤트 저장 후 fetch로 상태를 재조회하며, `생성/수정/삭제` → `상태 반영` → `렌더링 검증`의 흐름을 테스트 단위에서 재현
### 심화 과제

- [x] App 컴포넌트 적절한 단위의 컴포넌트, 훅, 유틸 함수로 분리했는가?
- [x] 해당 모듈들에 대한 적절한 테스트를 5개 이상 작성했는가?

## 과제 셀프회고

### 🧱 테스트 간 상태 격리

앞서 적은 내용과 같이, 테스트 간 영향을 줄이기 위해 `eventStore`를 전역으로 선언하고 각 테스트마다 `setupMockHandlerCreation()`을 호출해 새로운 인스턴스를 주입하는 방식으로 상태를 분리했다. 테스트는 항상 자신만의 초기 상태에서 시작되고 끝나며, 다른 테스트와 데이터를 공유하지 않는다.
이벤트 생성, 수정, 삭제 같은 상태 변화는 해당 테스트 내부에서만 일어나기 때문에, 다른 테스트에 영향을 주지 않고 원하는 동작만 검증할 수 있다. 테스트의 흐름과 사용하는 데이터가 명확하게 분리되고, 예기치 않은 충돌 없이 안정적으로 테스트를 구성할 수 있었다.


### 🧪 사용자 흐름 기반 테스트 설계
테스트는 되도록 실제 사용자 흐름을 기준으로 작성했다. 단순히 특정 컴포넌트가 렌더링됐는지를 확인하는 대신, 사용자가 일정을 입력하고 저장하고, 그 결과가 리스트나 달력에 어떻게 반영되는지까지 확인하는 식이다. 
`입력` → `저장` → `상태 갱신(fetch)` → `렌더링 확인`이라는 일련의 과정을 따라가며 테스트를 짜니, 실제 기능이 잘 이어지는지 명확히 파악할 수 있었다. 
이렇게 흐름 중심으로 테스트를 구성하면서 ‘이 테스트가 무엇을 검증하는가’가 뚜렷해졌고, 나중에 구조를 바꾸거나 기능을 수정할 때도 훨씬 쉽게 처리할 수 있었다.

### ⚖️ 테스트 코드의 양면성
이미 작성되어 있던 테스트 코드 덕분에 기능을 새로 만들거나 구조를 확장하는 과정은 수월했다. 테스트가 통과한다는 사실만으로도 변경에 대한 확인이 가능했고, 자연스럽게 리팩토링을 진행할 수 있었다.
하지만 기존 훅이나 컴포넌트를 분리하려는 시도는 오히려 주저하게 됐다. 기존 테스트들이 내부 구현에 밀접하게 결합되어 있어서, 구조를 손보려면 테스트까지 함께 수정해야 했기 때문이다. 
결국 일부 훅은 테스트와의 결합도를 고려해 구조 개선을 유보하게 되었고, 테스트가 유연한 리팩토링을 어렵게 만들 수도 있다는 점을 체감했다. 
테스트는 단순히 기능 검증을 넘어서, 구조에 어떤 제약을 줄 수 있는지도 고려해야 한다는 사실을 다시 한 번 확인한 경험이었다.

## 과제 중 질문 사항

### 통합 테스트의 커버리지는 어디까지가 적절할까?

테스트를 작성할 때마다 느꼈던 고민 중 하나는 ‘어디까지 테스트해야 하는가’였습니다. 
특히 통합 테스트의 경우, 단순한 입력-출력 검증을 넘어서 사용자의 흐름을 얼마나 세부적으로 재현해야 하는지 감이 잘 잡히지 않았습니다. 
이상적으로는 기능 정의서를 기준 삼아 커버리지를 정리하는 것이 맞겠지만, 현실적으로 그런 문서가 없는 경우도 많습니다. 
이럴 땐 어떤 기준을 가지고 테스트 범위를 결정하는 게 좋을까요?

### 테스트와 구현 간의 결합도, 어디까지 허용해야 할까?

테스트가 구조를 보호하는 역할을 하기도 하지만, 구현에 지나치게 결합되면 리팩토링의 장애물이 되기도 합니다. 
실제로 리팩토링 중 기존 훅(`useEventForm`) 내부 로직을 분리해보려 했지만, 테스트 코드가 그 구조에 강하게 의존하고 있어 손대기 어렵다고 판단해 포기한 경험이 있었습니다. 
이처럼 테스트와 구현 간의 결합도를 어느 수준까지 허용해야 할지, 혹은 테스트는 항상 외부 행위만 검증해야 하는 건지 궁금합니다.
